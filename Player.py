# -*- coding: utf-8 -*-
"""AI_HW2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JYJuUKwWXNKTzW9SI8jomnzzbgbLUzJl
"""

import numpy as np
import time

def ko_check(new_state, prev_state, died):
    if len(died) != 0:
        for i in range(0, 5):
            for j in range(0, 5):
                if new_state[i][j] != prev_state[i][j]:
                    return False
    else:
        return False

    return True


def sucidal_check(curr_state_, row, col, neighbors, player, opp_player):
    my_stack = []
    visited = []  # change it to dict
    died = []
    has_liberty = []
    flag_s = 0
    curr_state = curr_state_.copy()  # print(curr_state)

    my_stack.append((row, col))
    visited.append((row, col))

    curr_state[row][col] = player
    new_state = curr_state.copy()

    while len(my_stack) != 0:

        row, col = my_stack.pop()
        neigh_temp = neighbors[row][col]

        for N in neigh_temp:
            if curr_state[N[0]][N[1]] == '0':
                flag_s = 1
                break
            elif curr_state[N[0]][N[1]] == player and (N[0], N[1]) not in visited:
                my_stack.append((N[0], N[1]))
                visited.append((N[0], N[1]))
            else:
                visited.append((N[0], N[1]))

        if flag_s == 1:
            break

    ### Find the capture pices of opponent
    # chnage the implementation and only check the opponent pice position

    for i in range(0, 5):
        for j in range(0, 5):
            my_stack = []
            visited = []

            if curr_state[i][j] == opp_player and (i, j) not in died and (i, j) not in has_liberty:
                visited.append((i, j))
                my_stack.append((i, j))
                flag = 0

                while len(my_stack) != 0:
                    row, col = my_stack.pop()
                    # print("--------------------")
                    # print("stack", row, col)

                    neigh_temp = neighbors[row][col]
                    # print("N", neigh_temp)

                    for N in neigh_temp:

                        if curr_state[N[0]][N[1]] == '0':
                            # print("break", N)
                            flag = 1
                            break
                        elif curr_state[N[0]][N[1]] == opp_player and (N[0], N[1]) not in visited:
                            # print("stack insert",N)
                            my_stack.append((N[0], N[1]))
                            visited.append((N[0], N[1]))

                    if flag == 1:
                        has_liberty.extend(visited)
                        # print("lib", has_liberty)
                        break

                if flag != 1:
                    died.extend(visited)
                    # print("died", died)

    new_state = curr_state.copy()

    for d in died:
        new_state[d[0]][d[1]] = '0'

    if len(died) == 0 and flag_s == 0:
        return True, new_state, died
    else:
        return False, new_state, died


def overlap_check(curr_state, row, col):
    if curr_state[row][col] != '0':
        return True

    return False


def check_move(curr_state, prev_state, neighbors, player, opp_player, row, col):
    new_state, died = "", ""

    v1 = overlap_check(curr_state, row, col)  # check if there is any other player on the coordinate
    if v1 == True:
        return "Overlap issue", new_state, died

    v2, new_state, died = sucidal_check(curr_state, row, col, neighbors, player, opp_player)
    if v2 == True:
        return "Sucidal", new_state, died

    v3 = ko_check(new_state, prev_state, died)
    if v3 == True:
        return "KO", new_state, died

    return "Valid", new_state, died


def dimension_check(corr):
    return corr[0] % 5 == corr[0] and corr[1] % 5 == corr[1]


def get_neighbours():
    neigh = []
    for x in range(5):
        row = []
        for y in range(5):
            pn = ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1))
            row.append([corr for corr in pn if dimension_check(corr)])

        neigh.append(row)

    return neigh


def get_mat(player, curr_state, i, j):
    player_count = 0

    if 0 <= i < 5 and 0 <= j < 5 and curr_state[i][j] == player:
        player_count += 1

    if 0 <= i + 1 < 5 and 0 <= j < 5 and curr_state[i + 1][j] == player:
        player_count += 1

    if 0 <= i < 5 and 0 <= j + 1 < 5 and curr_state[i][j + 1] == player:
        player_count += 1

    if 0 <= i + 1 < 5 and 0 <= j + 1 < 5 and curr_state[i + 1][j + 1] == player:
        player_count += 1

    if player_count == 0 or player_count == 4:
        return "skip"
    elif player_count == 1:
        return "q1"
    elif player_count == 3:
        return "q3"
    elif player_count == 2:
        if (curr_state[0][0] == curr_state[1][1] or curr_state[0][1] == curr_state[1][0]):
            return "q2"

    return "skip"


def edge_case(curr_state, player):
    q1 = 0

    if curr_state[0][0] == player:
        q1 += 1

    if curr_state[0][4] == player:
        q1 += 1

    if curr_state[4][0] == player:
        q1 += 1

    for i in range(4):
        if (curr_state[i][0] != curr_state[i + 1][0]) and (
                curr_state[i][0] == player or curr_state[i + 1][0] == player):
            q1 += 1

    for i in range(4):
        if (curr_state[0][i] != curr_state[0][i + 1]) and (
                curr_state[0][i] == player or curr_state[0][i + 1] == player):
            q1 += 1

    return q1


def evaluation(curr_state, player1, player2, neighbors):
    stone_p1 = 0
    stone_p2 = 0

    liberty_p1 = 0
    liberty_p2 = 0

    edge_p1 = 0
    edge_p2 = 0

    corner_p1 = 0
    corner_p2 = 0

    visited_p1 = set()
    visited_p2 = set()

    q1_p1 = 0
    q2_p1 = 0
    q3_p1 = 0

    q1_p2 = 0
    q2_p2 = 0
    q3_p2 = 0

    for i in range(5):
        for j in range(5):

            res1 = get_mat(player1, curr_state, i, j)
            res2 = get_mat(player2, curr_state, i, j)

            if res1 == "q1":
                q1_p1 += 1
            elif res1 == "q2":
                q2_p1 += 1
            elif res1 == "q3":
                q3_p1 += 1

            if res2 == "q1":
                q1_p2 += 1
            elif res2 == "q2":
                q2_p2 += 1
            elif res2 == "q3":
                q3_p2 += 1

            if curr_state[i][j] == player1:
                stone_p1 = stone_p1 + 1

                if (i, j) in set(
                        [(0, 1), (0, 2), (0, 3), (1, 0), (2, 0), (3, 0), (4, 1), (4, 2), (4, 3), (1, 4), (2, 4),
                         (3, 4)]):
                    edge_p1 = edge_p1 + 1

                if (i, j) in set([(0, 0), (0, 4), (4, 0), (4, 4)]):
                    corner_p1 = corner_p1 + 1

                for n in neighbors[i][j]:
                    if n not in visited_p1:
                        visited_p1.add(n)
                        if curr_state[n[0]][n[1]] == '0':
                            liberty_p1 = liberty_p1 + 1

            elif curr_state[i][j] == player2:
                stone_p2 = stone_p2 + 1

                if (i, j) in set(
                        [(0, 1), (0, 2), (0, 3), (1, 0), (2, 0), (3, 0), (4, 1), (4, 2), (4, 3), (1, 4), (2, 4),
                         (3, 4)]):
                    edge_p2 = edge_p2 + 1

                if (i, j) in set([(0, 0), (0, 4), (4, 0), (4, 4)]):
                    corner_p2 = corner_p2 + 1

                for n in neighbors[i][j]:
                    if n not in visited_p2:
                        visited_p2.add(n)
                        if curr_state[n[0]][n[1]] == '0':
                            liberty_p1 = liberty_p1 + 1

    q1_p1 = q1_p1 + edge_case(curr_state, player1)
    q1_p2 = q1_p2 + edge_case(curr_state, player2)

    E1 = (q1_p1 - q3_p1 + 2 * q3_p1) / 4.0
    E2 = (q1_p2 - q3_p2 + 2 * q3_p2) / 4.0

    score = 5 * (stone_p1 - stone_p2) + min(max((liberty_p1 - liberty_p2), -4), 4) + (edge_p2 - edge_p1) + 2 * (
            corner_p2 - corner_p1) + 4 * (E2 - E1)
    return score


def minimax(curr_state, prev_state, neighbors, player, opp_player, depth, isMaximizing, alpha=-np.inf, beta=np.inf):
    if depth == 0:
        return evaluation(curr_state, player, opp_player, neighbors)

    if (isMaximizing):
        bestScore = -np.inf
        for i in range(5):
            for j in range(5):
                Valid, new_state, died = check_move(curr_state, prev_state, neighbors, player, opp_player, i, j)

                if Valid == "Valid":

                    score = minimax(new_state, curr_state, neighbors, player, opp_player, depth - 1, False, alpha, beta)

                    bestScore = max(score, bestScore)
                    alpha = max(alpha, score)

                    if beta <= alpha:
                        break

        return bestScore

    else:
        bestScore = np.inf

        for i in range(5):
            for j in range(5):
                Valid, new_state, died = check_move(curr_state, prev_state, neighbors, opp_player, player, i, j)

                if Valid == "Valid":
                    # print("opp")
                    # print(i, j)
                    score = minimax(new_state, curr_state, neighbors, player, opp_player, depth - 1, True, alpha, beta)
                    # print(score)
                    bestScore = min(score, bestScore)
                    beta = min(beta, score)

                    if beta <= alpha:
                        break

        return bestScore


def bestMove(curr_state, prev_state, neighbors, player, opp_player, depth):
    bestScore = -np.inf
    score_set = []
    cor_list = []
    for i in range(5):
        for j in range(5):
            Valid, new_state, died = check_move(curr_state, prev_state, neighbors, player, opp_player, i, j)

            if Valid == "Valid":
                
                score = minimax(new_state, curr_state, neighbors, player, opp_player, depth, False)
                

                score_set.append(score)
                cor_list.append((i, j))

                if (score > bestScore):
                    bestScore = score
                    move = (i, j)

    if bestScore != -np.inf:
        return move
    else:
        return "Pass"


def read_input():
    file = open("input.txt", "r+")
    out_file = open("output.txt", "w")
    lines = file.readlines()
    lines = [line.rstrip('\n') for line in lines]

    player = lines[0]
    if player == '1':
        opp_player = '2'
    else:
        opp_player = '1'

    prev_state = np.array([list(s) for s in lines[1:6]])
    curr_state = np.array([list(s) for s in lines[6:11]])

    neighbors = get_neighbours()
    depth = 2

    result = bestMove(curr_state, prev_state, neighbors, player, opp_player, depth)
    if result != "PASS":
        out_file.writelines(str(result[0]) + "," + str(result[1]))
    else:
        out_file.writelines("PASS")

    return result

read_input()

